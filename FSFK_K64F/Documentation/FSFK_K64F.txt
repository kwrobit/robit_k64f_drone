=============================================================================
List of generated methods in project: FSFK_K64F

This text description is generated by Processor Expert. Do not modify it.
=============================================================================

Module "MQX1"      (component MQXLite)
   - MQX1__int_default_isr -Default ISR that MQX calls if an unhandled interrupt or exception occurs.
   - MQX1__int_disable -The function _int_disable() disables all hardware interrupts at priorities up to and including the MQX 
                disable-interrupt level. As a result, no task can interrupt the active task while the active task is running 
                until interrupts are re-enabled with _int_enable(). If the active task blocks while interrupts are disabled, 
                the state of the interrupts (disabled or enabled) depends on the interrupt-disabled state of the next task that 
                MQX makes ready.
   - MQX1__int_enable -The function _int_enable() resets the processor priority to the hardware priority that corresponds to 
                the active task¡¯s software priority.
   - MQX1__int_exception_isr -To provide support for exception handlers, applications can use this ISR to replace the default 
                ISR. The ISR is specific to the PSP.   An application calls _int_install_exception_isr() to install 
                _int_exception_isr().   The function _int_exception_isr() does the following:   If an exception occurs when a 
                task is running and a task exception ISR exists, MQX runs the ISR;   If a task exception ISR does not exist, 
                MQX aborts the task by calling _task_abort().   If an exception occurs when an ISR is running and an ISR 
                exception ISR exists, MQX aborts the   running ISR and runs the ISR¡¯s exception ISR.   The function walks the 
                interrupt stack looking for information about the ISR or task that was   running before the exception occurred. 
                If the function determines that the interrupt stack contains   incorrect information, it calls 
                _mqx_fatal_error() with error code MQX_CORRUPT_INTERRUPT_STACK.
   - MQX1__int_get_default_isr -Gets a pointer to the default ISR that MQX calls when an unexpected interrupt occurs.
   - MQX1__int_get_exception_handler -Gets a pointer to the current ISR exception handler for the vector number.
   - MQX1__int_get_isr -Gets the current ISR for the vector number.
   - MQX1__int_get_isr_depth -Gets the depth of nesting of the current interrupt stack.
   - MQX1__int_get_isr_data -Gets the data that is associated with the vector number.
   - MQX1__int_get_kernel_isr -Gets a pointer to the kernel ISR for the vector number. The kernel ISR depends on the PSP.
   - MQX1__int_get_previous_vector_table -Gets the address of the interrupt vector table that MQX might have created when it 
                started.
   - MQX1__int_get_vector_table -Gets the address of the current interrupt vector table. The function depends on the PSP.
   - MQX1__int_install_default_isr -Installs an application-provided default ISR.
   - MQX1__int_install_kernel_isr -Installs the kernel ISR. The kernel ISR depends on the PSP.   Some real-time applications 
                need special event handling to occur outside the scope of MQX. The need   might arise that the latency in 
                servicing an interrupt be less than the MQX interrupt latency. If this is the   case, an application can use 
                _int_install_kernel_isr() to bypass MQX and let the interrupt be serviced   immediately.   Because the function 
                returns the previous kernel ISR, applications can temporarily install an ISR or chain   ISRs so that each new 
                one calls the one installed before it.   A kernel ISR must save the registers that it needs and must service 
                the hardware interrupt. When the kernel   ISR is finished, it must restore the registers and perform a 
                return-from-interrupt instruction.   A kernel ISR cannot call MQX functions. However, it can put data in global 
                data, which a task can access.
   - MQX1__int_install_isr -Installs the ISR. The application defines the ISR data, which can be a constant or a pointer to a 
                memory block from _mem_alloc().
   - MQX1__int_install_exception_isr -Installs the MQX-provided _int_exception_isr() as the default ISR for unhandled 
                interrupts and exceptions.
   - MQX1__int_install_unexpected_isr -Installs the MQX-provided unexpected ISR, _int_unexpected_isr(), for all interrupts that 
                do not have an application-installed ISR.
   - MQX1__int_kernel_isr -Default kernel ISR that MQX calls to intercept all interrupts.
   - MQX1__int_set_exception_handler -The function sets the exception handler for an ISR. When an exception (unhandled 
                interrupt) occurs while   the ISR is running, MQX calls the exception handler and terminates the ISR.   An 
                application should install _int_exception_isr() as the MQX default ISR.   The returned exception handler is 
                either the default handler or one that the application previously installed   with _int_set_exception_handler().
   - MQX1__int_set_isr_data -Sets the data associated with the interrupt.
   - MQX1__int_set_vector_table -Changes the location of the interrupt vector table.
   - MQX1__int_unexpected_isr -An MQX-provided default ISR for unhandled interrupts. The function depends on the PSP.
   - MQX1__klog_create_at -
   - MQX1__klog_get_interrupt_stack_usage -Gets the size of the interrupt stack and the total amount of it used.
   - MQX1__klog_get_task_stack_usage -Gets the size of the interrupt stack and the total amount of it used.   The amount used 
                is a highwater mark?the highest amount of interrupt stack that the application has used   so far. It shows only 
                how much of the stack has been written to at this point. If the amount is 0, the interrupt   stack is not large 
                enough.
   - MQX1__klog_control -Controls logging in kernel log.   The application must first create kernel log with _klog_create().   
                The function _klog_control() sets or clears bits in the kernel log control variable, which MQX uses to   
                control logging. To select which functions to log, set combinations of bits in the   KLOG_FUNCTIONS_ENABLED 
                flag for the bit_mask parameter.   MQX logs to kernel log only if KLOG_ENABLED is set in bit_mask.
   - MQX1__klog_disable_logging_task -Disables kernel logging for the task.   If the application calls _klog_control() with 
                KLOG_TASK_QUALIFIED, it must call   _klog_enable_logging_task() for each task for which it wants to log 
                information.   The application disables logging by calling _klog_disable_logging_task() for each task for which 
                it wants   to stop logging. If the application did not first enable logging for the task, MQX ignores the 
                request.
   - MQX1__klog_display -Displays the oldest entry in kernel log and delete the entry.   The function prints the oldest entry 
                in kernel log to the default output stream of the current task and deletes the entry.
   - MQX1__klog_enable_logging_task -Enables kernel logging for the task.   If the application calls _klog_control() with 
                KLOG_TASK_QUALIFIED, it must call   _klog_enable_logging_task() for each task for which it wants to log 
                information.   The application disables logging by calling _klog_disable_logging_task() for each task for which 
                it wants   to stop logging. If the application did not first enable logging for the task, MQX ignores the 
                request.
   - MQX1__klog_show_stack_usage -Displays the amount of interrupt stack used and the amount of stack used by each task.   The 
                function displays the information on the standard output stream for the calling task.
   - MQX1__lwsem_create -Creates the lightweight semaphore.
   - MQX1__lwsem_destroy -Destroys the lightweight semaphore.
   - MQX1__lwsem_poll -Poll for the lightweight semaphore.
   - MQX1__lwsem_post -Posts the lightweight semaphore.
   - MQX1__lwsem_test -Tests the data structures (including queues) of the lightweight semaphores component.
   - MQX1__lwsem_wait -Wait (in FIFO order) for the lightweight semaphore until it is available.
   - MQX1__lwsem_wait_ticks -Wait (in FIFO order) for the lightweight semaphore for the number of ticks (in tick time)
   - MQX1__lwsem_wait_for -Wait (in FIFO order) for the lightweight semaphore for the number of ticks
   - MQX1__lwsem_wait_until -Wait (in FIFO order) for the lightweight semaphore until the specified time (in tick time)
   - MQX1__mem_zero -Fills the region of memory with 0x0.
   - MQX1__mem_test_and_set -Tests and sets a memory location.   The function can be used to implement mutual exclusion between 
                tasks. If the single-addressable unit was 0, the function sets the high bit. If possible, the function uses a 
                bus-cycle indivisible instruction.
   - MQX1__mqx_exit -Terminate the MQX application and return to the environment that started the application.
   - MQX1__mqx_fatal_error -Indicates that an error occurred that is so severe that MQX or the application can no longer 
                function.
   - MQX1__mqx_get_counter -Gets a unique number.
   - MQX1__mqx_get_cpu_type -Gets the CPU type.
   - MQX1__mqx_get_initialization -Gets a pointer to the MQX initialization structure.
   - MQX1__mqx_get_kernel_data -Gets a pointer to kernel data.
   - MQX1__mqx_get_exit_handler -Gets a pointer to the MQX exit handler, which MQX calls when it exits.
   - MQX1__mqx_get_system_task_id -Gets the task ID of System Task.
   - MQX1__mqx_get_tad_data -Gets the TAD_RESERVED field from the task descriptor.
   - MQX1__mqx_idle_task -Idle Task is an MQX task that runs if all application tasks are blocked. The function implements a 
                simple counter, whose size depends on the CPU.
   - MQX1__mqx_set_cpu_type -The function sets CPU_TYPE in kernel data. The MQX Host Tools family of products uses CPU type. 
                CPU types begin with PSP_CPU_TYPE_ and are defined in source\\psp\\cpu_family\\cpu_family.h.
   - MQX1__mqx_set_exit_handler -Sets the address of the MQX exit handler, which MQX calls when it exits.
   - MQX1__sched_get_max_priority -Gets the maximum priority that a task can be.
   - MQX1__sched_get_min_priority -Gets the minimum priority that an application task can be.
   - MQX1__sched_yield -Puts the active task at the end of its ready queue. The function effectively performs a timeslice. If 
                there are no other tasks in this ready queue, the task continues to be the active task.
   - MQX1__task_abort -Makes a task run its task exit handler and then destroys itself.
   - MQX1__task_block -Blocks the active task. The function removes the active task from the task¡¯s ready queue and sets the 
                BLOCKED bit in the STATE field of the task descriptor. The task does not run again until another task 
                explicitly makes it ready with _task_ready().
   - MQX1__task_check_stack -Determines whether the stack for the active task is currently out of bounds.   The function 
                indicates whether the stack is currently past its limit. The function does not indicate whether the stack 
                previously passed its limit.
   - MQX1__task_create_at -Creates the task with the stack location specified
   - MQX1__task_destroy -Destroys the task.   The function does the following for the task being destroyed:   Frees memory 
                resources that the task allocated with functions from the _mem and _partition   families.   Closes all queues 
                that the task owns and frees all the queue elements.   Frees any other component resources that the task owns.
   - MQX1__task_disable_fp -Disables floating-point context switching for the active task if the   task is a floating-point 
                task.
   - MQX1__task_enable_fp -Enables floating-point context switching for the active task.
   - MQX1__task_get_creator -Gets the task ID of the task that created the calling task.
   - MQX1__task_get_environment -Gets a pointer to the application-specific environment data for the task.
   - MQX1__task_get_exception_handler -Gets a pointer to the task exception handler.
   - MQX1__task_get_error -Sets the task error code.   MQX uses the function to indicate an error. MQX never sets the task 
                error code to MQX_OK; that is, MQX   does not reset the task error code. It is the responsibility of the 
                application to reset the task error code.   As a result, when an application calls _task_get_error(), it gets 
                the first error that MQX detected since the   last time the application reset the task error code.
   - MQX1__task_get_error_ptr -Gets a pointer to the task error code.
   - MQX1__task_get_exit_handler -Gets a pointer to the task exit handler for the task.
   - MQX1__task_get_id_from_name -Gets the task ID that is associated with the task name.
   - MQX1__task_get_index_from_id -Gets the task template index for the task ID.
   - MQX1__task_get_parameter -Gets the task creation parameter of the active task.
   - MQX1__task_get_parameter_for -Gets the task creation parameter of the specified task
   - MQX1__task_get_processor -
   - MQX1__task_get_priority -Gets the priority of the task.
   - MQX1__task_get_td -Gets a pointer to the task descriptor for the task ID.
   - MQX1__task_get_template_index -Gets the pointer to the task template for the task ID.
   - MQX1__task_ready -Makes the task ready to run by putting it in its ready queue.
   - MQX1__task_restart -Restarts the task.
   - MQX1__task_set_environment -Sets the address of the application-specific environment   data for the task.
   - MQX1__task_set_error -Sets the task error code.
   - MQX1__task_set_exception_handler -Sets the address of the task exception handler.
   - MQX1__task_set_exit_handler -Sets the address of the task exit handler for the task.
   - MQX1__task_set_parameter -
   - MQX1__task_set_parameter_for -Sets the task creation parameter of the specified task.
   - MQX1__task_set_priority -Sets the priority of the task.
   - MQX1__task_stop_preemption -Disables preemption of the current task.
   - MQX1__task_start_preemption -Enables preemption of the current task.
   - MQX1__taskq_create -Creates a task queue.
   - MQX1__taskq_destroy -Destroys the task queue.
   - MQX1__taskq_resume -Restarts the task that is suspended in the task queue.
   - MQX1__taskq_suspend -Suspends the active task and put it in the task queue.
   - MQX1__taskq_suspend_task -Suspends the ready task in the task queue.
   - MQX1__taskq_test -Tests the task queues.
   - MQX1__taskq_get_value -Gets the number of tasks that are in the task queue.
   - MQX1__time_delay_ticks -Suspend the active task for the number of ticks.
   - MQX1__time_diff_ticks -Get the difference between two tick times.
   - MQX1__time_get_elapsed_ticks -Get the time in this format since MQX started tick time.
   - MQX1__time_get_hwticks -Gets the number of hardware ticks since the last tick.
   - MQX1__time_get_hwticks_per_tick -Gets the number of hardware ticks per tick.
   - MQX1__time_get_ticks -Get the absolute time in tick time
   - MQX1__time_get_ticks_per_sec -Gets the timer frequency (in ticks per second) that MQX uses.
   - MQX1__time_init_ticks -Initializes a tick time structure with the number of ticks.
   - MQX1__time_notify_kernel -The BSP periodic timer ISR calls the function when a periodic timer interrupt occurs.
   - MQX1__time_set_hwtick_function -Set the fields in kernel data to get the hardware ticks.
   - MQX1__time_set_hwticks_per_tick -Sets the number of hardware ticks per tick.
   - MQX1__time_set_resolution -Sets the resolution of the periodic timer interrupt.
   - MQX1__time_set_ticks -Set the absolute time in tick time
   - MQX1__time_set_ticks_per_sec -Sets the timer frequency (in ticks per second) that MQX uses.
   - MQX1__time_set_timer_vector -Sets the periodic timer interrupt vector number that MQX uses.
   - MQX1__lwevent_create -Initializes the lightweight event group.
   - MQX1__lwevent_destroy -Deinitializes the lightweight event group.
   - MQX1__lwevent_set -Sets the specified event bits in the lightweight event group.
   - MQX1__lwevent_set_auto_clear -Sets autoclearing behavior of event bits in the lightweight event group.
   - MQX1__lwevent_clear -Clears the specified event bits in the lightweight event group.
   - MQX1__lwevent_wait_for -Wait for the specified lightweight event bits to be set in the lightweight event group for the 
                number of ticks (in tick time).
   - MQX1__lwevent_wait_ticks -Wait for the specified lightweight event bits to be set in the lightweight event group for the 
                number of ticks
   - MQX1__lwevent_wait_until -Wait for the specified lightweight event bits to be set in the lightweight event group until the 
                specified time (in tick time)
   - MQX1__lwevent_get_signalled -Gets which particular bit(s) in the lwevent unblocked recent wait command.
   - MQX1__lwevent_test -Tests the lightweight event component.
   - MQX1__mutatr_destroy -Deinitializes the mutex attributes structure.
   - MQX1__mutatr_get_priority_ceiling -Gets the priority value of the mutex attributes structure.
   - MQX1__mutatr_get_sched_protocol -Gets the scheduling protocol of the mutex attributes.
   - MQX1__mutatr_get_spin_limit -Gets the spin limit of the mutex attributes structure.
   - MQX1__mutatr_get_wait_protocol -Gets the waiting policy of the mutex attributes structure.
   - MQX1__mutatr_set_priority_ceiling -Sets the priority value of the mutex attributes structure.
   - MQX1__mutatr_set_sched_protocol -
   - MQX1__mutatr_set_spin_limit -Sets the spin limit of the mutex attributes structure.
   - MQX1__mutatr_set_wait_protocol -Sets the waiting policy of the mutex attributes structure.
   - MQX1__mutatr_init -Initializes the mutex attributes structure to default values.
   - MQX1__mutex_create_component -Creates the mutex component.
   - MQX1__mutex_destroy -Deinitializes the mutex.
   - MQX1__mutex_get_priority_ceiling -
   - MQX1__mutex_get_wait_count -Gets the number of tasks that are waiting for the mutex.
   - MQX1__mutex_init -Initializes the mutex.
   - MQX1__mutex_set_priority_ceiling -Sets the priority of the mutex.
   - MQX1__mutex_test -Tests the mutex component.
   - MQX1__mutex_unlock -
   - MQX1__mutex_try_lock -Tries to lock the mutex.
   - MQX1__lwlog_calculate_size -Calculates the number of single-addressable units required for the lightweight log.
   - MQX1__lwlog_create_at -Creates the lightweight log at the specific location.
   - MQX1__lwlog_create_component -Creates the lightweight log component.
   - MQX1__lwlog_destroy -Destroys the lightweight log.
   - MQX1__lwlog_disable -Stops logging to the lightweight log.
   - MQX1__lwlog_enable -
   - MQX1__lwlog_read -Reads the information in the lightweight log.
   - MQX1__lwlog_reset -Resets the lightweight log to its initial state (remove all entries).
   - MQX1__lwlog_test -Tests the lightweight log component.
   - MQX1__lwlog_write -Writes to the lightweight log.
   - MQX1__lwmsgq_init -Create a lightweight message queue.
   - MQX1__lwmsgq_send -Put a message on a lightweight message queue.
   - MQX1__lwmsgq_receive -Get a message from a lightweight message queue.
   - MQX1__lwtimer_add_timer_to_queue -Adds the lightweight timer to the periodic queue.
   - MQX1__lwtimer_cancel_period -Cancels all the lightweight timers in the periodic queue.
   - MQX1__lwtimer_cancel_timer -Cancels the outstanding timer request.
   - MQX1__lwtimer_create_periodic_queue -Creates the periodic timer queue.
   - MQX1__lwtimer_test -Tests all the periodic queues and their lightweight timers for validity and consistency.

Module "LED_RED"   (component BitIO_LDD)
   - LED_RED_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" value 
                then the device is also enabled(see the description of the Enable() method). In this case the Enable() method 
                is not necessary and needn't to be generated.
   - LED_RED_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is read and returned (see <Safe mode> 
                property for limitations). This method cannot be disabled if direction is [input].
   - LED_RED_PutVal -The specified output value is set. If the direction is <b>input</b>, the component saves the value to a 
                memory or a register and this value will be written to the pin after switching to the output mode (using 
                <tt>SetDir(TRUE)</tt>; see <a href="BitIOProperties.html#SafeMode">Safe mode</a> property for limitations). If 
                the direction is <b>output</b>, it writes the value to the pin. (Method is available only if the direction = 
                <u><tt>output</tt></u> or <u><tt>input/output</tt></u>).
   - LED_RED_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - LED_RED_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.
   - LED_RED_NegVal -Negates (inverts) the output value. It is equivalent to the [PutVal(!GetVal())]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.

Module "LED_GREEN" (component BitIO_LDD)
   - LED_GREEN_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and 
                sets interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" 
                value then the device is also enabled(see the description of the Enable() method). In this case the Enable() 
                method is not necessary and needn't to be generated.
   - LED_GREEN_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is read and returned (see <Safe mode> 
                property for limitations). This method cannot be disabled if direction is [input].
   - LED_GREEN_PutVal -The specified output value is set. If the direction is <b>input</b>, the component saves the value to a 
                memory or a register and this value will be written to the pin after switching to the output mode (using 
                <tt>SetDir(TRUE)</tt>; see <a href="BitIOProperties.html#SafeMode">Safe mode</a> property for limitations). If 
                the direction is <b>output</b>, it writes the value to the pin. (Method is available only if the direction = 
                <u><tt>output</tt></u> or <u><tt>input/output</tt></u>).
   - LED_GREEN_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - LED_GREEN_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.
   - LED_GREEN_NegVal -Negates (inverts) the output value. It is equivalent to the [PutVal(!GetVal())]. This method is 
                available only if the direction = _[output]_ or _[input/output]_.

Module "FTM"       (component TimerUnit_LDD)
   - FTM_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.
   - FTM_SetPeriodTicks -The method sets timer re-initialization period (in timer ticks). This method is available only if the 
                property <"Counter restart"> is switched to 'on-match' value.
   - FTM_GetPeriodTicks -Returns the number of counter ticks before re-initialization. See also method <SetPeriodTicks>. This 
                method is available only if the property <"Counter restart"> is switched to 'on-match' value.
   - FTM_GetCounterValue -Returns the content of counter register. This method can be used both if counter is enabled and if 
                counter is disabled. The method is not available if HW doesn't allow reading of the counter.

Module "UART_A"    (component Serial_LDD)
   - UART_A_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" value 
                then the device is also enabled(see the description of the Enable() method). In this case the Enable() method 
                is not necessary and needn't to be generated.
   - UART_A_SendBlock -Sends a block of characters. The method returns ERR_BUSY when the previous block transmission is not 
                completed. Method <CancelBlockTransmission> can be used to cancel a transmit operation. This method is 
                available only if the transmitter property is enabled. This method finishes immediately after calling it - it 
                doesn't wait the end of data transmission. Use event <OnBlockSent> to check the end of data transmission or 
                method GetSentDataNum to check the state of sending.
   - UART_A_ReceiveBlock -Specifies the number of data to receive. The method returns ERR_BUSY until the specified number of 
                characters is received. Method <CancelBlockReception> can be used to cancel a running receive operation. If a 
                receive operation is not in progress (the method was not called or a previous operation has already finished) 
                all received characters will be lost without any notification. To prevent the loss of data call the method 
                immediately after the last receive operation has finished (e.g. from the <OnBlockReceived> event). This method 
                finishes immediately after calling it - it doesn't wait the end of data reception. Use event <OnBlockReceived> 
                to check the end of data reception or method GetReceivedDataNum to check the state of receiving.
   - UART_A_GetSentDataNum -Returns the number of sent characters.
   - UART_A_GetReceivedDataNum -Returns the number of received characters in the receive buffer.

Module "UART_B"    (component Serial_LDD)
   - UART_B_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" value 
                then the device is also enabled(see the description of the Enable() method). In this case the Enable() method 
                is not necessary and needn't to be generated.
   - UART_B_SendBlock -Sends a block of characters. The method returns ERR_BUSY when the previous block transmission is not 
                completed. Method <CancelBlockTransmission> can be used to cancel a transmit operation. This method is 
                available only if the transmitter property is enabled. This method finishes immediately after calling it - it 
                doesn't wait the end of data transmission. Use event <OnBlockSent> to check the end of data transmission or 
                method GetSentDataNum to check the state of sending.
   - UART_B_ReceiveBlock -Specifies the number of data to receive. The method returns ERR_BUSY until the specified number of 
                characters is received. Method <CancelBlockReception> can be used to cancel a running receive operation. If a 
                receive operation is not in progress (the method was not called or a previous operation has already finished) 
                all received characters will be lost without any notification. To prevent the loss of data call the method 
                immediately after the last receive operation has finished (e.g. from the <OnBlockReceived> event). This method 
                finishes immediately after calling it - it doesn't wait the end of data reception. Use event <OnBlockReceived> 
                to check the end of data reception or method GetReceivedDataNum to check the state of receiving.
   - UART_B_GetSentDataNum -Returns the number of sent characters.
   - UART_B_GetReceivedDataNum -Returns the number of received characters in the receive buffer.

Module "I2C"       (component I2C_LDD)
   - I2C_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc.   If the "Enable in init. code" is set to "yes" value 
                then the device is also enabled(see the description of the Enable() method). In this case the Enable() method 
                is not necessary and needn't to be generated.    This method can be called only once. Before the second call of 
                Init() the Deinit() must be called first.
   - I2C_MasterSendBlock -This method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive of 
                R/W bit = 0 to the I2C bus and then writes the block of characters to the bus. The slave address must be 
                specified before, by the "SelectSlaveDevice" method or in component initialization section, "Target slave 
                address init" property. If the method returns ERR_OK, it doesn't mean that transmission was successful. The 
                state of transmission is detectable by means of events (OnMasterSendComplete or OnError). Data to be sent are 
                not copied to an internal buffer and remains in the original location. Therefore the content of the buffer 
                should not be changed until the transmission is complete. Event "OnMasterBlockSent"can be used to detect the 
                end of the transmission. This method is available only for the MASTER or MASTER - SLAVE mode.
   - I2C_MasterGetBlockSentStatus -This method returns current state of MasterSendBlock method. This method is available only 
                for the MASTER mode and if method MasterSendBlock is enabled.
   - I2C_MasterReceiveBlock -This method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive 
                of R/W bit = 1 to the I2C bus and then receives the block of characters from the bus. The slave address must be 
                specified before, by the "SelectSlaveDevice" method or in component initialization section, "Target slave 
                address init" property. If the method returns ERR_OK, it doesn't mean that reception was successful. The state 
                of reception is detectable by means of events (OnMasterSendComplete  or OnError). Data to be received are not 
                copied to an internal buffer and remains in the original location. Therefore the content of the buffer should 
                not be changed until the transmission is complete. Event "OnMasterBlockReceived"can be used to detect the end 
                of the reception. This method is available only for the MASTER or MASTER - SLAVE mode.
   - I2C_MasterGetBlockReceivedStatus -This method returns current state of MasterReceiveBlock method. This method is available 
                only for the MASTER mode and if method MasterReceiveBlock is enabled.
   - I2C_SelectSlaveDevice -This method selects a new slave for communication by its 7-bit slave, 10-bit address or general 
                call value. Any send or receive method directs to or from selected device, until a new slave device is selected 
                by this method. This method is available for the MASTER mode.
   - I2C_GetError -Returns value of error mask, e.g. LDD_I2C_ARBIT_LOST.
   - I2C_CheckBus -This method returns the status of the bus. If the START condition has been detected, the method returns 
                LDD_I2C_BUSY. If the STOP condition has been detected, the method returns LDD_I2C_IDLE.

Module "TI1"       (component TimerInt)

Module "TU1"       (component TimerUnit_LDD)
   - TU1_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.

Module "ROTOR1"    (component PWM)
   - ROTOR1_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.
   - ROTOR1_SetDutyUS -This method sets the new duty value of the output signal. The duty is expressed in microseconds as a 
                16-bit unsigned integer number. The method is available only if it is not selected list of predefined values in 
                <Starting pulse width> property.
   - ROTOR1_SetDutyMS -This method sets the new duty value of the output signal. The duty is expressed in milliseconds as a 
                16-bit unsigned integer number. The method is available only if it is not selected list of predefined values in 
                <Starting pulse width> property.

Module "TU2"       (component TimerUnit_LDD)
   - TU2_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.
   - TU2_GetPeriodTicks -Returns the number of counter ticks before re-initialization. See also method <SetPeriodTicks>. This 
                method is available only if the property <"Counter restart"> is switched to 'on-match' value.
   - TU2_GetCounterValue -Returns the content of counter register. This method can be used both if counter is enabled and if 
                counter is disabled. The method is not available if HW doesn't allow reading of the counter.
   - TU2_SetOffsetTicks -Sets the new offset value to channel specified by the parameter ChannelIdx. It is user responsibility 
                to use value below selected period. This method is available when at least one channel is configured.
   - TU2_GetOffsetTicks -Returns the number of counter ticks to compare match channel specified by the parameter ChannelIdx. 
                See also method <SetOffsetTicks>. This method is available when at least one channel is configured.
   - TU2_SelectOutputAction -Sets the type of compare match and counter overflow action on channel output. This method is 
                available when at least one channel is configured.

Module "ROTOR2"    (component PWM)
   - ROTOR2_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.
   - ROTOR2_SetDutyUS -This method sets the new duty value of the output signal. The duty is expressed in microseconds as a 
                16-bit unsigned integer number. The method is available only if it is not selected list of predefined values in 
                <Starting pulse width> property.
   - ROTOR2_SetDutyMS -This method sets the new duty value of the output signal. The duty is expressed in milliseconds as a 
                16-bit unsigned integer number. The method is available only if it is not selected list of predefined values in 
                <Starting pulse width> property.

Module "ROTOR3"    (component PWM)
   - ROTOR3_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.
   - ROTOR3_SetDutyUS -This method sets the new duty value of the output signal. The duty is expressed in microseconds as a 
                16-bit unsigned integer number. The method is available only if it is not selected list of predefined values in 
                <Starting pulse width> property.
   - ROTOR3_SetDutyMS -This method sets the new duty value of the output signal. The duty is expressed in milliseconds as a 
                16-bit unsigned integer number. The method is available only if it is not selected list of predefined values in 
                <Starting pulse width> property.

Module "ROTOR4"    (component PWM)
   - ROTOR4_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.
   - ROTOR4_SetDutyUS -This method sets the new duty value of the output signal. The duty is expressed in microseconds as a 
                16-bit unsigned integer number. The method is available only if it is not selected list of predefined values in 
                <Starting pulse width> property.
   - ROTOR4_SetDutyMS -This method sets the new duty value of the output signal. The duty is expressed in milliseconds as a 
                16-bit unsigned integer number. The method is available only if it is not selected list of predefined values in 
                <Starting pulse width> property.

Module "RC"        (component AsynchroSerial)
   - RC_RecvChar -If any data is received, this method returns one character, otherwise it returns an error code (it does not 
                wait for data). This method is enabled only if the receiver property is enabled.  [Note:] Because the preferred 
                method to handle error and break exception in the interrupt mode is to use events <OnError> and <OnBreak> the 
                return value ERR_RXEMPTY has higher priority than other error codes. As a consequence the information about an 
                exception in interrupt mode is returned only if there is a valid character ready to be read.
   - RC_SendChar -Sends one character to the channel. If the component is temporarily disabled (Disable method) SendChar method 
                only stores data into an output buffer. In case of a zero output buffer size, only one character can be stored. 
                Enabling the component (Enable method) starts the transmission of the stored data. This method is available 
                only if the transmitter property is enabled.
   - RC_RecvBlock -If any data is received, this method returns the block of the data and its length (and incidental error), 
                otherwise it returns an error code (it does not wait for data).  This method is available only if non-zero 
                length of the input buffer is defined and the receiver property is enabled.  If less than requested number of 
                characters is received only the available data is copied from the receive buffer to the user specified 
                destination. The value ERR_EXEMPTY is returned and the value of variable pointed by the Rcv parameter is set to 
                the number of received characters.
   - RC_ClearRxBuf -Clears the receive buffer.  This method is available only if non-zero length of the input buffer is defined 
                and the receiver property is enabled.
   - RC_GetCharsInRxBuf -Returns the number of characters in the input buffer. This method is available only if the receiver 
                property is enabled.
   - RC_GetCharsInTxBuf -Returns the number of characters in the output buffer. This method is available only if the 
                transmitter property is enabled.

Module "Cpu"       (component MK64FN1M0LL12)

===================================================================================
